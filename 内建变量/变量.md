# 如何实现变量私有化？
- 以`_a`,`__a`进行命名
    - 以from ... import * 导入不了
    - 以from ... impory=t _a,__a 可以导入成功
- 以__all__进行限制

# bool类型为什么可以和int相加？
bool类继承了int

# 变量值交换发生了什么？
a,b = 3,1
a,b = b,a
- a = 3;b=1
- 压包tuple：tmp = (b,a) = (1,3)
- 解包：a,b = *tmp = *(1,3) 
- **原来的a，b如果没有掉用则被回收**

如果有调用的话是会直接影响的，比如链表：prev = None;cur = ListNode，`prev,prev.next,cur = cur,prev,cur.next`
因为python中的gc回收中计数非0的变量不会被回收。同时，我们可以看到无论取数还是赋值操作都是从左往右执行的

# LEGB规定
在变量查找的过程中，优先local查找，没有查找到的话则按直接外围作用域查找，查找顺序为local->global->builtin，在闭包中的体现尤为明显。
```python
a = 1
def foo():
    a = 2
    def bar():
        print(a  )
    return bar
```    

# 介绍一下整python内的整数对象
- c中对int带有两个属性
    - 标记回收计数值，用来回收变量
    - 对象信息类，用来刻画int基本信息
        - 缓存了[-5，257）的数据到small_ints链表，python自带地址永远相等
        - C中long类型数值的扩展
        - 整数对象回收时，内存并不会归还给系统，指向下一个PyIntObject的指针，原值进入缓存区

# 介绍一下整python内的字符串对象
- char数组进行存储
- 字符串属于不可变对象
- intern机制保证存储效率，核心是一个类似key-value的字典
    - intern处理后的字符串，比如"Python"，在解释器运行过程中始终只有唯一的一个字符串"Python"对应的PyStringObject对象。
- 字符串有专门的缓冲池存储长度为1的字符串对象

# Python列表对象实现原理
- 列表对象引用计数
- 列表类型对象      
- 列表元素的长度
- 真正存放列表元素容器的指针

# Python字典对象实现原理
- 数据添加：把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。
- 数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。

# Python字典keyhash冲突的解决方法
- 链接法
- 开放寻址法（python用的方法）
    - 探测函数不停寻址
    - 探测逻辑结合链表+链表三状态（unused/active/dummy）
        - dummy是为了防止删除字典导致链表断裂

# tuple 和 list差别
- 地址不可变 VS 可变
- tuple可以用作生成器

# 解释一下字符串 Intern 机制
对字符串进行 intern 机制处理，处理后返回字符串对象。我们发现但凡是值相同的字符串经过 intern 机制处理之后，返回的都是同一个字符串对象，这种方式在处理大数据的时候无疑能节省更多的内存空间，系统无需为相同的字符串重复分配内存，对于值相同的字符串共用一个对象即可
- 实现方式是：dict
- 纯字符串的string已经默认使用了intern机制